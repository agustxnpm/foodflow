#!/bin/bash

# FoodFlow CLI - Script de orquestación del proyecto
# Uso: ./ff <comando> [argumentos]

set -e

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$PROJECT_ROOT"

# Archivos de control
BACKEND_PID_FILE="$PROJECT_ROOT/.backend.pid"
BACKEND_LOG_FILE="$PROJECT_ROOT/logs/backend.log"

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Mata cualquier proceso Java corriendo en el puerto 8080
kill_backend() {
    log_info "Verificando procesos del backend..."
    
    # Matar por PID file si existe
    if [ -f "$BACKEND_PID_FILE" ]; then
        local pid=$(cat "$BACKEND_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            log_warn "Matando proceso backend existente (PID: $pid)"
            kill -9 "$pid" 2>/dev/null || true
            sleep 1
        fi
        rm -f "$BACKEND_PID_FILE"
    fi
    
    # Matar cualquier proceso en el puerto 8080
    local port_pid=$(lsof -ti:8080 2>/dev/null || true)
    if [ -n "$port_pid" ]; then
        log_warn "Puerto 8080 ocupado por PID $port_pid, matando proceso..."
        kill -9 $port_pid 2>/dev/null || true
        sleep 1
    fi
    
    # Matar cualquier proceso Maven/Spring Boot corriendo
    pkill -9 -f "spring-boot:run" 2>/dev/null || true
    pkill -9 -f "FoodFlowApplication" 2>/dev/null || true
    
    sleep 1
    log_info "Procesos limpiados"
}

# Comando: up
# Levanta la base de datos y el backend
cmd_up() {
    log_info "Levantando servicios de FoodFlow..."
    
    # Matar cualquier proceso previo
    kill_backend
    
    # Levantar PostgreSQL en Docker
    log_info "Iniciando PostgreSQL en Docker..."
    docker compose up -d
    
    # Esperar a que PostgreSQL esté listo
    log_info "Esperando a que PostgreSQL esté listo..."
    sleep 3
    
    # Crear directorio de logs si no existe
    mkdir -p "$PROJECT_ROOT/logs"
    
    # Levantar backend en background
    log_info "Iniciando backend Spring Boot en segundo plano..."
    nohup ./mvnw spring-boot:run > "$BACKEND_LOG_FILE" 2>&1 &
    local backend_pid=$!
    echo $backend_pid > "$BACKEND_PID_FILE"
    
    log_info "Backend iniciado (PID: $backend_pid)"
    log_info "Ver logs con: ./ff logs backend"
    log_info ""
    log_info "✓ Servicios levantados exitosamente"
    log_info "  - PostgreSQL: localhost:5433"
    log_info "  - Backend API: http://localhost:8080"
    log_info ""
    log_info "Usa './ff logs backend' para ver los logs en tiempo real"
}

# Comando: down
# Baja todos los servicios
cmd_down() {
    log_info "Bajando servicios de FoodFlow..."
    
    # Matar backend
    kill_backend
    
    # Bajar Docker Compose
    docker compose down
    
    log_info "✓ Todos los servicios detenidos"
}

# Comando: restart
# Reinicia servicios
cmd_restart() {
    local service="$1"
    
    if [ -z "$service" ]; then
        log_info "Reiniciando todos los servicios..."
        cmd_down
        cmd_up
    else
        log_info "Reiniciando servicio: $service"
        docker compose restart "$service"
    fi
}

# Comando: test
# Ejecuta tests
cmd_test() {
    local test_name="$1"
    
    if [ -z "$test_name" ]; then
        log_info "Ejecutando todos los tests..."
        ./mvnw test
    else
        log_info "Ejecutando test: $test_name"
        ./mvnw test -Dtest="$test_name"
    fi
}

# Comando: staging
# Ejecuta scripts SQL de staging
cmd_staging() {
    local sql_file="$1"
    
    if [ -z "$sql_file" ]; then
        log_error "Debe especificar un archivo SQL"
        log_info "Uso: ./ff staging <archivo.sql>"
        exit 1
    fi
    
    if [ ! -f "$sql_file" ]; then
        log_error "Archivo no encontrado: $sql_file"
        exit 1
    fi
    
    log_info "Ejecutando script SQL: $sql_file"
    
    # Ejecutar SQL contra el contenedor de PostgreSQL
    docker compose exec -T db psql -U foodflow_user -d foodflow_db -f - < "$sql_file"
    
    log_info "Script ejecutado exitosamente"
}

# Comando: logs
# Muestra logs de los servicios
cmd_logs() {
    local service="$1"
    
    if [ "$service" = "backend" ]; then
        if [ ! -f "$BACKEND_LOG_FILE" ]; then
            log_error "No se encontró el archivo de logs del backend"
            log_info "¿El backend está corriendo? Usa './ff up' para iniciarlo"
            exit 1
        fi
        log_info "Mostrando logs del backend (Ctrl+C para salir)..."
        tail -f "$BACKEND_LOG_FILE"
    elif [ -z "$service" ]; then
        docker compose logs -f
    else
        docker compose logs -f "$service"
    fi
}

# Comando: db
# Acceso directo a psql
cmd_db() {
    log_info "Conectando a PostgreSQL..."
    docker compose exec db psql -U foodflow_user -d foodflow_db
}

# Comando: clean
# Limpia build artifacts
cmd_clean() {
    log_info "Limpiando build artifacts..."
    ./mvnw clean
    log_info "Limpieza completada"
}

# Mostrar ayuda
show_help() {
    cat << EOF
FoodFlow CLI - Herramienta de desarrollo

Uso: ./ff <comando> [argumentos]

Comandos disponibles:

  up                          Levanta PostgreSQL (Docker) y backend en segundo plano
  down                        Baja TODOS los servicios (incluyendo backend)
  restart [servicio]          Reinicia todos los servicios o uno específico
  test [nombre]               Ejecuta todos los tests o uno específico
  staging <script.sql>        Ejecuta un script SQL de staging
  logs [servicio]             Muestra logs de los servicios
                              - logs backend: logs del backend Spring Boot
                              - logs db: logs de PostgreSQL
                              - logs: todos los logs de Docker
  db                          Abre una consola psql en el contenedor
  clean                       Limpia build artifacts de Maven

Ejemplos:

  ./ff up                     # Levanta todo en background
  ./ff logs backend           # Ver logs del backend en tiempo real
  ./ff logs db                # Ver logs de PostgreSQL
  ./ff down                   # Baja TODO (limpia procesos colgados)
  ./ff test                   # Ejecuta todos los tests
  ./ff test ConsultarMesasUseCaseTest
  ./ff staging scripts/seed-data.sql
  ./ff restart
  ./ff db

Notas:
  - El backend corre en segundo plano después de './ff up'
  - Los logs del backend están en: logs/backend.log
  - './ff down' mata TODOS los procesos, incluso si quedaron colgados con Ctrl+Z

EOF
}

# Router principal
case "${1:-}" in
    up)
        cmd_up
        ;;
    down)
        cmd_down
        ;;
    restart)
        cmd_restart "$2"
        ;;
    test)
        cmd_test "$2"
        ;;
    staging)
        cmd_staging "$2"
        ;;
    logs)
        cmd_logs "$2"
        ;;
    db)
        cmd_db
        ;;
    clean)
        cmd_clean
        ;;
    help|--help|-h)
        show_help
        ;;
    "")
        log_error "Debe especificar un comando"
        show_help
        exit 1
        ;;
    *)
        log_error "Comando desconocido: $1"
        show_help
        exit 1
        ;;
esac
